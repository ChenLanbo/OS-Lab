*********************************************************************************
Lab4b Exercise 7 Challenge, sfork()

	Implementation:

	We just copy page mappings from UTEXT to USTACKTOP - PGSIZE in parent to the
	child with the same permissions. And we copy-on-write parent's stack to the
	child. Finally we allocate a new page for the child's exception stack.

	See lib/fork.c functions: duppage2, sfork

	Testing:

	In order to test sfork(), I modify use/forktree.c as following:

		int var = 0
		void umain(void){
			int pid;
			cprintf("Before sfork() var = %d\n", var);
			pid = sfork();

			// Child
			if (pid == 0)
				var = 1;
			else
				sys_yield();

			if (pid == 0){
				cprintf("After sfork() var = %d in child\n", var);
			} else {
				cprintf("After sfork() var = %d in parent\n", var);
			}
		}
	
	Since parent and child share the same memory, after child modifies the var,
	parent also get the same value.

	Testing Result:

	Run make qemu-nox and get the following results:

	...
	Before sfork() var = 0
	[00001001] new env 00001002
	pgfault 00001001
	pgfault 00001002
	After sfork() var = 1 in child
	[00001002] exiting gracefully
	[00001002] free env 00001002
	After sfork() var = 1 in parent
	[00001001] exiting gracefully
	[00001001] free env 00001001
	...

*********************************************************************************
