Name: Lanbo Chen
ID  : #108079696
Lab2: Challenge Problems

*****************************************************************************************************
Challenge 1: space-efficient Kernel mapping using PTE_PS
	
	When mapping [KERNBASE, 2^32) to [0, 2^32 - KERNBASE), first set the perm argument to be 
	'PTE_W | PTE_PS' in boot_map_segment.

	In function boot_map_segment, check if the perm has PTE_PS on. If so, set the page 
	directory entry to be 'pa | perm | PTE_P'. 

		for (i = 0; i < size; i += PTSIZE){
			entry = &pgdir[PDX(la + i)];
			*entry = (physaddr_t)(pa + i) | perm | PTE_P;
		}
	
	Since a page directory entry can represent 4MB physical page and the kernel has max memory 
	of 256MB, we just need to set the values of 64 page directory entries from KERNBASE. Thus 
	we save 64 4K pages.

	At last, in function i386_vm_init, we have to set the CR4_PSE bit in cr4 register in order 
	to enable 4MB page extention.  This is done after installing page table first time and 
	before turing on paging.

		cr4 = rcr4();
		cr4 |= CR4_PSE;
		lcr4(cr4);

	TEST:

	To test the solution, we need to add monitor command showmappings which is described in
	challenge 2 to show the physical address mapping of virtual address. To test the solution
	is right, we just need to show the base physical mappings are the same for different 
	virtual address. Examples are here:

		K> showmappings 0xf0000000
		0xf0000000: mapped to physical page at address 0x00000000
	     	Flags: PTE_W PTE_A PTE_D PTE_PS PTE_MBZ

		K> showmappings 0xf0001000
		0xf0001000: mapped to physical page at address 0x00000000
		     Flags: PTE_W PTE_A PTE_D PTE_PS PTE_MBZ
	
	Without PTE_PS set, virtual address 0xf0000000 and 0xf0001000 are supposed to be mapped
	to different physical address. Here we can see they are both mapped to 0x00000000.

*****************************************************************************************************
Challenge 2: Monitor commands extension

	I add two new files which are 'memutil.h' and 'memutil.c' in kern/ to define memory mangement 
	commands.

	showmappings: show the physical page mappings of given virtual addresses

		USAGE: showmappings virtual_address ...

		OUTPUT: if the virtual address is not mapped into physical page physical, then just output no 
				mapping. Otherwise, show the page physical address and permissions.

		Use pgdir_walk in pmap.c

		TEST:

		K> showmappings 0xf0000000 0xf0001000
		0xf0000000: mapped to physical page at address 0x00000000
		     Flags: PTE_W PTE_A PTE_D PTE_PS PTE_MBZ

	 	0xf0001000: mapped to physical page at address 0x00000000
			 Flags: PTE_W PTE_A PTE_D PTE_PS PTE_MBZ

		K> showmappings 0x00010000
		0x00010000: currently has no mapping


	mapping_chmod: explicitly set & clear the permissions of any mapping in the current address space

		USAGE: mapping_chmod [+Perm] [-Perm] virtual_address

		Return : 0 success, 1 error
				 For any wrong input or no mapping of given virtual address, the function
				 return 1
		Allowed permission: PTE_W, PTE_U, PTE_PWT, PTE_PCD, PTE_A, PTE_D, PTE_MBZ

	memdump: dump the memory contents

		USAGE: memdump [-p] [range] address
				    -p  dump the physical memory contents
				 range  the range of memory in bytes start from address
			   address  starting address in hexdecimal format like 0x00000000

		OUTPUT: show every byte content from [address, address + range). If it is to dump physical
				memory, first check if each address in the range is out of physical memory range, 
				and then use KADDR macro to convert the address. If it is to dump virtual address,
				then just use pgdir_walk in pmap.c to get the page table entry and see if it has
				been mapped. If the address is out of range or not mapped, just output zero.

		TEST:

		K> memdump -p 16 0x00100000
		       Memdump:
		    0x00100000: 02 b0 ad 1b
		    0x00100004: 03 00 00 00
		    0x00100008: fb 4f 52 e4

	    K> memdump 16 0xf0100000
	           Memdump:
	        0xf0100000: 02 b0 ad 1b
		    0xf0100004: 03 00 00 00
		    0xf0100008: fb 4f 52 e4


Challenge 3:

Challenge 4:

Challenge 5: add alloc_page, page_status, free_page commands

	These three functions are defined in memutil.h and memutil.c

	alloc_page: alloc a page of 4KB
		Usage: alloc_page
		Return: 1 --> no free memory available
				0 --> success, and output new allocated page's physical address

	page_status: show the physical page status given page's physcial address
		Usage: page_status [address]
			   with 0 argument, page_status show all the pages allocated by alloc_page

	free_page: free the allocated page given page's physical address
		Usage: free_page address
