Name: Lanbo Chen
ID  : #108079696

*********************************************************************************
Lab4c Exercise 10 Challenge 1(fairness), 2(non-loop ipc_send).

	Implementation:

	In order to improve the fairness of current ipc, I let the kernel maintain a
	message queue to store the message from one process to another. Here is basic
	idea:
	
	1. When process A tries to send a message to process B, if B is waiting for
	   message, then we just follow the original work flow.
	2. If B is currently runnable, then we add A's message into the back of 
	   kernel's message queue, mark B as blocked and return.
	3. If process A calls sys_ipc_recv, it first check if there's any message to
	   A itself in kernel's message queue. If so, the kernel pops a message at
	   the front of the queue and passes it to A. Otherwise, mark A as blocked.

	To make the ipc_send as non-looping, I modify the sys_ipc_send syscall to be
	a blocking call. In other words, when process A is currently runable and B is
	sending a message, put the message into the queue and mark B as blocked. As 
	mentioned above, when next time A calls ipc_recv, it gets a message of B from
	the queue, then A can mark B as runnable, since the message has been 
	successfully delivered.

	See kern/myipc.h, kern/myipc.c and kern/syscall.c for detail code.

	Testing Result of user/fairness.c:

	In libmain, about to start user program
	In libmain, about to start user program
	1002 loop sending to 1001
	In libmain, about to start user program
	1003 loop sending to 1001
	1001 recv from 1002
	1001 recv from 1002
	1001 recv from 1003
	1001 recv from 1002
	1001 recv from 1002
	1001 recv from 1003
	1001 recv from 1002
	1001 recv from 1002
	1001 recv from 1003
	1001 recv from 1002
	1001 recv from 1002
	1001 recv from 1003
	...
	   
*********************************************************************************

*********************************************************************************
Lab4b Exercise 7 Challenge, sfork()

	Implementation:

	We just copy page mappings from UTEXT to USTACKTOP - PGSIZE in parent to the
	child with the same permissions. And we copy-on-write parent's stack to the
	child. Finally we allocate a new page for the child's exception stack.

	See lib/fork.c functions: duppage2, sfork

	Testing:

	In order to test sfork(), I modify use/forktree.c as following:

		int var = 0
		void umain(void){
			int pid;
			cprintf("Before sfork() var = %d\n", var);
			pid = sfork();

			// Child
			if (pid == 0)
				var = 1;
			else
				sys_yield();

			if (pid == 0){
				cprintf("After sfork() var = %d in child\n", var);
			} else {
				cprintf("After sfork() var = %d in parent\n", var);
			}
		}
	
	Since parent and child share the same memory, after child modifies the var,
	parent also get the same value.

	Testing Result:

	Run make qemu-nox and get the following results:

	...
	Before sfork() var = 0
	[00001001] new env 00001002
	pgfault 00001001
	pgfault 00001002
	After sfork() var = 1 in child
	[00001002] exiting gracefully
	[00001002] free env 00001002
	After sfork() var = 1 in parent
	[00001001] exiting gracefully
	[00001001] free env 00001001
	...

*********************************************************************************

